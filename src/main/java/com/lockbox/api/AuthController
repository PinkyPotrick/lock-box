package com.lockbox.api;

import com.lockbox.dto.UserRegistrationDTO;
import com.lockbox.dto.SrpParamsDTO;
import com.lockbox.dto.SrpAuthenticateDTO;
import com.lockbox.service.SrpService;
import com.lockbox.model.User;
import com.lockbox.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.math.BigInteger;

@RestController
@RequestMapping("/api/auth")
public class AuthController {

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private TokenService tokenService;

    @Autowired
    private SrpService srpService;

    @Autowired
    private HttpSession httpSession;  // Injecting HttpSession for session management

    @Autowired
    private RSAKeyPairService rsaKeyPairService;

    @PostConstruct
    public void init() {
        System.out.println("AuthController initialized");
    }

    @GetMapping("/public-key")
    public String getPublicKey() {
        return "Test Public Key";
        // return rsaKeyPairService.getPublicKey();
    }

    @PostMapping("/register")
    public Map<String, String> registerUser(@Valid @RequestBody UserRegistrationDTO request) {
        // Decrypt the received data
        String username = rsaKeyPairService.decrypt(request.get("username"));
        String email = rsaKeyPairService.decrypt(request.get("email"));
        String salt = rsaKeyPairService.decrypt(request.get("salt"));
        String verifier = rsaKeyPairService.decrypt(request.get("verifier"));

        // Check if the username or email already exists
        if (userRepository.findByUsername(srpService.encryptData(username)) != null) {
            throw new RuntimeException("Username already exists");
        }

        // Encrypt and store user data
        User user = new User();
        user.setUsername(srpService.encryptData(username));
        user.setEmail(srpService.encryptData(email));
        user.setSalt(srpService.encryptData(salt));
        user.setVerifier(srpService.encryptData(verifier));
        user.setCreatedAt(srpService.encryptData(LocalDate.now().toString()));

        userRepository.save(user);

        // Generate and encrypt the session token with the client's public key
        String sessionToken = tokenService.generateToken(user);
        String clientPublicKey = rsaKeyPairService.decrypt(request.get("clientPublicKey"));
        String encryptedSessionToken = rsaKeyPairService.encryptWithClientPublicKey(sessionToken, clientPublicKey);

        // Return the encrypted session token to the client
        Map<String, String> response = new HashMap<>();
        response.put("encryptedSessionToken", encryptedSessionToken);

        return response;
    }

    @PostMapping("/srp-params")
    public Map<String, String> getSrpParams(@Valid @RequestBody SrpParamsDTO request) {
        // Decrypt the received data
        String username = rsaKeyPairService.decrypt(request.get("username"));
        BigInteger A = new BigInteger(rsaKeyPairService.decrypt(request.get("A")), 16);

        // Retrieve user information
        User user = userRepository.findByUsername(srpService.encryptData(username));
        if (user == null) {
            throw new RuntimeException("User not found");
        }

        // Compute B and send it along with the salt
        BigInteger b = srpService.generatePrivateValue();
        BigInteger B = srpService.computeB(user.getVerifier(), b);
        String salt = srpService.decryptData(user.getSalt());

        // Store values in session
        httpSession.setAttribute("A", A);
        httpSession.setAttribute("B", B);
        httpSession.setAttribute("b", b);
        httpSession.setAttribute("username", username);

        Map<String, String> response = new HashMap<>();
        response.put("salt", salt);
        response.put("B", B.toString(16));

        return response;
    }

    @PostMapping("/srp-authenticate")
    public Map<String, String> authenticate(@Valid @RequestBody SrpAuthenticateDTO request) {
        // Decrypt the received data
        String username = rsaKeyPairService.decrypt(request.get("username"));
        String M1 = rsaKeyPairService.decrypt(request.get("M1"));

        // Retrieve session data and user information
        BigInteger A = (BigInteger) httpSession.getAttribute("A");
        BigInteger B = (BigInteger) httpSession.getAttribute("B");
        BigInteger b = (BigInteger) httpSession.getAttribute("b");
        // String username = (String) httpSession.getAttribute("username"); // this shouldn't be needed theoretically
        
        User user = userRepository.findByUsername(srpService.encryptData(username));
        if (user == null || sessionData == null) {
            throw new RuntimeException("Session expired or invalid");
        }

        // Compute S, K, and M2
        BigInteger u = srpService.computeU(A, B);
        BigInteger v = new BigInteger(srpService.decryptData(user.getVerifier()), 16);
        BigInteger S = srpService.computeS(A, v, u, B);
        byte[] K = srpService.computeK(S);

        // Verify M1
        String expectedM1 = srpService.computeM1(A, B, S, K);
        if (!expectedM1.equals(M1)) {
            throw new RuntimeException("Client verification failed");
        }

        // Generate M2
        String M2 = srpService.computeM2(A, M1, S, K);

        // Generate and encrypt the session token with the client's public key
        String sessionToken = tokenService.generateToken(user);
        String encryptedSessionToken = rsaKeyPairService.encryptWithClientPublicKey(sessionToken, clientPublicKey);

        // Clear session attributes after successful authentication
        httpSession.invalidate(); // TODO check if this is ultimately needed

        // Return M2 and the encrypted session token
        Map<String, String> response = new HashMap<>();
        response.put("encryptedM2", rsaKeyPairService.encryptWithClientPublicKey(M2, clientPublicKey));
        response.put("encryptedSessionToken", encryptedSessionToken);

        return response;
    }
}
